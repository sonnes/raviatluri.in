---
author: Ravi Atluri
date: 2025-04-03
title: Introducing XDB
description: XDB is a new kind of database library based on tuples. Rather than writing database specific schemas, queries, and migrations, XDB allows developers to model their domain once and use it with one or more databases.
tags:
  - xdb
  - golang
---

XDB is a new kind of database library based on tuples.

Rather than writing database-specific schemas, queries, and migrations, XDB allows developers to model their domain once and use it with one or more databases.

XDB separates the application domain model from the underlying database(s) by using a simple yet powerful data model based on tuples. This lets developers focus on modeling, ingesting, and querying dataâ€”without worrying about the underlying database infrastructure or operations.

## Why?

Not all databases are created equal. Most applications at scale use multiple types of databases:

- PostgreSQL/MySQL as the main database
- Redis for caching
- Elasticsearch for search
- Clickhouse for analytics
- BigTable for versioning

Each database solves a specific problem and comes with its own tradeoffs.

An application's domain model is often a combination of data that resides in different databases. Typically, each database has its own abstraction layer for migrations and queries. Sometimes, new microservices are spun up to manage specific use cases like search, analytics, or caching.

At the end of the day, developers must stitch together domain data from multiple databases or microservices to serve user-facing APIs. Looking at an end-to-end flow, there are several layers of data fetching, mutation, and transformation. Every time a feature adds new fields or relationships, the entire stack goes through churn.

XDB aims to separate the application domain model from database implementation and operations. What if, instead of maintaining multiple database-specific implementations, developers could model their domain once and seamlessly work with multiple databases?

## Inspiration

XDB draws inspiration from two key concepts: **Data Services** and **N-Quads**.

Data services are intermediary services that sit between APIs and databases. They provide simple APIs for your domain data, while automating and abstracting away the underlying database management.

<Image src="/images/introducing-xdb/data-services.png" alt="Data Services" />

[N-Quad](https://www.w3.org/TR/n-quads/) is a well-known format used to represent attributes and relationships in graphs.

```
<Post:9bsv0s5ocl6002kdg0fg> <title> "Hello World" .
<Post:9bsv0s5ocl6002kdg0fg> <description> "..." .
<Post:9bsv0s5ocl6002kdg0fg> <author> <1> .
<Post:9bsv0s5ocl6002kdg0fg> <created_at> "2025-04-01T00:00:00Z"
<Post:9bsv0s5ocl6002kdg0fg> <tags> <golang> .
<Post:9bsv0s5ocl6002kdg0fg> <tags> <xdb> .
<User:1> <follows> <User:2> .
<User:2> <likes> <Post:9bsv0s5ocl6002kdg0fg> .
```

XDB was inspired by Dgraph's [Mutation API](https://github.com/hypermodeinc/dgo/blob/8fd6df819e01c401e89f57601fba40e5631a27de/protos/api.proto#L68), which uses N-Quads to insert or update data. What if this idea could be extended to build an abstraction usable with any database?

## Data Model

XDB is built around three core types - **Tuple**, **Edge**, and **Record**.

### Tuple

A **Tuple** combines a kind, id, attribute name, value, and optional metadata.

<Image src="/images/introducing-xdb/tuple.png" alt="Tuple" />

This simple yet powerful structure can represent any domain model and is easily mappable to various database formats.

Creating a tuple is as simple as:

```go
tuple := xdb.NewTuple("Post", "9bsv0s5ocl6002kdg0fg", "title", "Hello World")
```

### Edge

An **Edge** is a special kind of tuple whose value is a reference. Edges are unidirectional and represent relationships between records.

### Record

A **Record** is a collection of tuples that share the same kind and id. Records are similar to objects, structs, or rows in a database.


Create a record with tuples as:

```go
record := xdb.NewRecord("Post", "9bsv0s5ocl6002kdg0fg").
	Set("title", "Hello World").
	Set("description", "...").
	Set("created_at", time.Now()).
	Set("author_id", "1").
	Set("tags", []string{"golang", "xdb"})
```

## Using XDB as Library

XDB can be used as a library replacing the traditional repository/database layer in Go services.

Let's see XDB in action. First, we'll define a simple domain model using standard Go structs:

```go
type Post struct {
	ID          string    `xdb:"id,primary_key"`
	Title       string    `xdb:"title"`
	Description string    `xdb:"description"`
	CreatedAt   time.Time `xdb:"created_at"`
	AuthorID    string    `xdb:"author_id"`
	Tags        []string  `xdb:"tags"`
}
```

Now let's create, store, and retrieve a post:

```go
// Create a new post
post := &Post{
	ID:          "9bsv0s5ocl6002kdg0fg",
	Title:       "Hello World",
	Description: "A sample post about XDB",
	CreatedAt:   time.Now(),
	AuthorID:    "1",
	Tags:        []string{"golang", "xdb"},
}

// Convert the struct to a record
record, err := xdbstruct.Marshal(post)
if err != nil {
	log.Fatal(err)
}

// Create a new store using any of the driver implementations
store := xdbmemory.New()

// Store the record in the database
err = store.PutRecord(ctx, record)
if err != nil {
	log.Fatal(err)
}

// Retrieve the record from the database
record, err = store.GetRecord(ctx, record.Key())
if err != nil {
	log.Fatal(err)
}

// Convert the record back to a struct
var fetchedPost Post
err = xdbstruct.Unmarshal(record, &fetchedPost)
if err != nil {
	log.Fatal(err)
}
```

This example uses an in-memory store, but XDB supports multiple database backends through its driver interface.

## Routing Data

But the real power of XDB is in its ability to "route" the same domain model to different databases. You can create a "routing" layer that moves around tuples, edges, and records between different databases.

```go
type RecordRouter struct {
	Primary   xdb.RecordWriter 	// e.g. PostgreSQL
	Cache     xdb.RecordWriter 	// e.g. Redis
	Indexer   xdb.RecordIndexer // e.g. Elasticsearch
}

func (r *RecordRouter) PutRecord(ctx context.Context, record *xdb.Record) error {
	// Save complete record to primary database as source of truth.
	r.Primary.PutRecord(ctx, record)

	// Then update the cache.
	r.Cache.PutRecord(ctx, record)

	// For search, only index relevant fields.
	indexRecord := record.Keep("title", "description", "author", "tags")

	r.Indexer.IndexRecord(ctx, indexRecord)
}

func (r *RecordRouter) GetRecord(ctx context.Context, key *xdb.Key) (*xdb.Record, error) {
	// Get the record from cache.
	record, err := r.Cache.GetRecord(ctx, key)
	if err != nil {
		return nil, err
	}

	// If not found, get from primary database.
	if record == nil {
		record, err = r.Primary.GetRecord(ctx, key)
		if err != nil {
			return nil, err
		}

		// Update the cache.
		r.Cache.PutRecord(ctx, record)
	}

	return record, nil
}
```

This flexibility allows you to distribute specific attributes of your domain model to the most appropriate databases. It also reduces redundant code for retries, error handling, monitoring, etc.

## Building Blocks

XDB APIs are designed to be simple, concise, composable, and easy to use.

### Core Types

The core types used to create tuples, edges, and records.

### Encoding

Encoding APIs are used to encode and decode tuples, edges, and records to and from JSON, Protobuf, Go structs, etc.

### Drivers

Drivers are database-specific implementations that translate between XDB's tuple-based model and the database's data model.

XDB exposes interfaces for drivers to implement. Each interface is like a **capability** that a database supports.

The most basic capabilities like storing & retrieving tuples, edges, and records are implemented by all databases. More capabilities like search, aggregation, iteration, edge traversal, etc. are optional and implemented by specific drivers.

### Stores

Stores are implemented by combining different drivers with different capabilities. Stores provide higher-level APIs for common use-cases. For example, a **Cache Store** might provide an API for getting a record from cache or a **Search Store** might provide an API for searching records.

### Schema

Schema APIs are used to define database-agnostic schemas of application domain models. Schema APIs are used by drivers to generate database-specific schemas and manage migrations.
